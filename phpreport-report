#!/usr/bin/env python
#
# Copyright (C) 2012, 2013 Igalia S.L.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

from phpreport import Customer
from phpreport import Project
from phpreport import PHPReport
from phpreport import User
from phpreport import TaskFilter

import argparse
import base64
import datetime
import multiprocessing
import re
import textwrap
import sys
import time
import urllib
import urllib2

class PeriodOfWork(object):
    def __init__(self, start_date, num_days, filter=TaskFilter()):
        self.start_date = start_date
        self.num_days = num_days
        self.users = set()
        self.tasks = None
        self.filter = filter.create_instance_for_dates(
            self.get_date_for_day_offset(0),
            self.get_date_for_day_offset(num_days - 1))

    def get_users(self):
        self.get_tasks_if_necessary()
        return self.users

    def get_tasks_if_necessary(self):
        if self.tasks == None:
            PeriodOfWork.fetch_tasks_for_all([self])

    def set_tasks(self, tasks):
        self.tasks = tasks
        for task in self.tasks:
            self.users.add(task.user)

    def filter_tasks(self, date=None, day_offset=None, user=None, only_onsite=False):
        self.get_tasks_if_necessary()
        if date == None and day_offset != None:
            date = self.get_date_for_day_offset(day_offset)

        def filter_task(task):
            if user != None and task.user != user:
                return False
            if date != None and task.date != date:
                return False
            if only_onsite and not(task.onsite):
                return False
            return True
        return filter(filter_task, self.tasks)

    def get_all_dates(self):
        return [self.start_date + datetime.timedelta(offset) for offset in xrange(0, self.num_days)]

    def get_date_for_day_offset(self, day_offset):
        return self.start_date + datetime.timedelta(day_offset)

    def time_worked(self, date=None, day_offset=None, user=None, only_onsite=False):
        return sum([task.length() for task in self.filter_tasks(date, day_offset, user, only_onsite)], datetime.timedelta())

    @staticmethod
    def fetch_tasks_for_all(periods):
        tasks = PHPReport.get_tasks_for_task_filters([period.filter for period in periods])
        for pair in zip(periods, tasks):
            pair[0].set_tasks(pair[1])

class WeekOfWork(PeriodOfWork):
    def __init__(self, week, year, filter=TaskFilter()):
        self.week = week
        self.year = year

        week_as_string = "%i %i 1" % (year, week)
        start_date = datetime.datetime.strptime(week_as_string, "%Y %W %w").date()

        # ISO8601 considers the first week of the year the first one that contains
        # a Thursday, but strptime does not. We need to account for that.
        if datetime.date(year, 1, 4).isoweekday() > 4:
            start_date -= datetime.timedelta(days=7)

        super(WeekOfWork, self).__init__(start_date, 7, filter)

    def __str__(self):
        return "Week %i of %i" % (self.week, self.year)

    def short_string(self):
        return "Week %i" % self.week

    def wiki_string(self):
        return "Week%i-%i" % (self.week, self.year)

    @classmethod
    def create_from_string(cls, string, filter):
        default_year = datetime.datetime.today().isocalendar()[0]

        def split_single(string):
            if not '/' in string:
                return default_year, int(string.strip())
            else:
                week, year = string.split('/')
                return int(year.strip()), int(week.strip())

        if not "-" in string and not "," in string:
            split = split_single(string)
            return [cls(split[1], split[0], filter)]

        result = []
        for week_range in string.split(","):
            range_bounds = week_range.split("-")

            if len(range_bounds) == 1:
                start = end = result.append(split_single(range_bounds))
            else:
                # FIXME: We don't yet support spanning a year.
                start = split_single(range_bounds[0])
                end = split_single(range_bounds[1])

            for week in range(start[1], end[1] + 1):
                result.append(cls(week, start[0], filter))

        cls.fetch_tasks_for_all(result)
        return result


def format_delta(delta):
    return "%02i:%02i" % (delta.days * 24 + delta.seconds // 3600, (delta.seconds // 60) % 60)

class AggregateReport(object):
    def __init__(self, time_periods, formatter, repot_name):
        self.time_periods = time_periods
        self.formatter = formatter
        self.report_name = repot_name

    def generate_report(self):
        self.formatter.generate_header("%s to %s for %s" % \
            (self.time_periods[0],
             self.time_periods[-1],
             self.time_periods[0].filter))

        table_contents = []
        total = datetime.timedelta()
        total_onsite = datetime.timedelta()
        for period in self.time_periods:
            amount = period.time_worked()
            amount_onsite = period.time_worked(only_onsite=True)
            total += amount
            total_onsite += amount_onsite
            table_contents.append([period.short_string(), "%s (%s)" % (format_delta(amount), format_delta(amount_onsite))])
        self.formatter.generate_table(table_contents, has_headers=False)

        self.formatter.generate_header("Total hours worked: %s" % format_delta(total))
        self.formatter.generate_header("Total onsite hours worked: %s" % format_delta(total_onsite))
        return self.formatter.flatten()

    def wiki_string(self):
        if self.report_name != None:
            return self.report_name
        return "%sTo%s" % (self.time_periods[0].wiki_string(), self.time_periods[-1].wiki_string())

class DetailedReport(object):
    def __init__(self, time_period, formatter):
        self.time_period = time_period
        self.formatter = formatter

    @staticmethod
    def format_date(date):
        return date.strftime("%d %b")

    def time_worked(self, user=None, total=False):
        if total:
            return [format_delta(self.time_period.time_worked(user=user))]
        all_dates = self.time_period.get_all_dates()
        return [format_delta(self.time_period.time_worked(date=x, user=user)) for x in all_dates]

    def generate_hours(self):
        table = []
        table.append([""] + map(DetailedReport.format_date, self.time_period.get_all_dates()) + ["Total"])
        for user in self.time_period.get_users():
            table.append([user.login] + \
                         self.time_worked(user=user) + \
                         self.time_worked(user=user, total=True))
        table.append(["everyone"] + \
                     self.time_worked() + \
                     self.time_worked(total=True))
        self.formatter.generate_table(table)

        onsite_time = self.time_period.time_worked(only_onsite=True)
        if onsite_time > datetime.timedelta(0):
            self.formatter.generate_large_text("Onsite hours worked: %s" % format_delta(onsite_time))

    def get_stories_for_day_and_user(self, user, date):
        tasks_for_day = self.time_period.filter_tasks(date=date, user=user)
        all_stories = " ".join([task.text + task.story for task in tasks_for_day])

        # Strip out duplicated whitespace
        return re.compile(r'\s+').sub(' ', all_stories).strip()

    def generate_stories_for_user(self, user):
        self.formatter.generate_section_header("Stories for %s" % user.login)

        all_dates = self.time_period.get_all_dates()
        contents = [(date.strftime("%A"), self.get_stories_for_day_and_user(user, date)) for date in all_dates]
        self.formatter.generate_aligned_list(contents)

    def generate_report(self):
        self.pieces = []
        self.formatter.generate_header("%s for %s" % (str(self.time_period), self.time_period.filter))
        self.generate_hours()
        for user in self.time_period.users:
            self.generate_stories_for_user(user)
        return self.formatter.flatten()

    def wiki_string(self):
        return self.time_period.wiki_string()

class TextFormatter(object):
    def __init__(self):
        self.pieces = []

    def generate_table_row(self, columns, lengths, header=False):
        format_string = ""
        for length in lengths:
            format_string += "%%-%i.%is  " % (length, length)
        self.pieces.append(format_string % tuple(columns))
        self.pieces.append("\n")

    @staticmethod
    def generate_column_length_list(table):
        lengths = map(lambda x: map(len, x), table) # Generate a table of lengths.
        # Turn the table of lengths into a row of max lengths for each column.
        return map(max, zip(*lengths))

    def generate_table(self, table, has_headers=True):
        if not len(table):
            return

        lengths = TextFormatter.generate_column_length_list(table)
        self.generate_table_row(table[0], lengths, header=has_headers)
        for row in table[1:]:
            self.generate_table_row(row, lengths)

    def generate_aligned_list(self, contents):
        first_column_size = max([len(content[0]) for content in contents])
        format_string = "%%%i.%is: %%s\n" % (first_column_size, first_column_size)

        indent = (first_column_size + 2) * ' ' # Enough to account for the day name offset.
        width = 80 - len(indent)
        for content in contents:
            second_column = textwrap.fill(content[1],
                                          break_long_words=False, # Don't break URLs.
                                          width=width,
                                          initial_indent=indent,
                                          subsequent_indent=indent).strip()
            self.pieces.append(format_string % (content[0], second_column))

    def generate_header(self, header):
        self.pieces.append("\n%s\n" % header)

    def generate_section_header(self, header):
        self.pieces.append("\n%s\n" % header)

    def generate_large_text(self, text):
        self.pieces.append("%s\n" % text)

    def flatten(self):
        return "".join(self.pieces)

class TwikiFormatter(TextFormatter):
    def generate_table_row(self, columns, lengths=None, header=False, highlight_first=True):
        first = "| *%s* "
        if not highlight_first:
            first = "| %s"

        if header:
            format_string = first + (len(columns) - 2) * " | *%s*" + " | *%s* |"
        else:
            format_string = first + (len(columns) - 2) * " | %s" + " | %s |"

        self.pieces.append(format_string % tuple(columns))
        self.pieces.append("\n")

    def generate_table(self, table, has_headers=True):
        if len(table) < 10 or has_headers:
            return super(TwikiFormatter, self).generate_table(table, has_headers)

        def chunks_of_n(l, n):
            for i in xrange(0, len(l), n):
                yield l[i:i+n]

        def transpose_to_columns(lists):
            return map(lambda *row: [elem or ['', ''] for elem in row], *lists)

        table = chunks_of_n(table, 10)
        table = transpose_to_columns(table)
        for row in table:
            # Now we have a row of pairs, but we need to flatten it.
            row = sum(row, [])
            self.generate_table_row(row, highlight_first=False)

    def generate_header(self, header):
        self.pieces.append("\n---++%s\n" % header)

    def generate_section_header(self, header):
        self.pieces.append("\n---++++%s\n" % header)

    def generate_aligned_list(self, contents):
        for content in contents:
            self.pieces.append("   * *%s* - %s\n" % (content[0], content[1]))

def send_url_request(request):
    try:
        urllib2.urlopen(request)
    except Exception as e:
        print e
        print "Could not complete upload to TWiki at %s" % request.get_full_url()

class TwikiUploader(object):
    def __init__(self, url, section="Main", username=None, password=None):
        self.url = url
        self.section = section
        self.username=username
        self.password=password

    def add_links_for_short_strings(self, contents, time_periods):
        for time_period in time_periods:
            short_string = time_period.short_string()
            contents = contents.replace("%s" % short_string,
                                        "[[%s][%s]] " % (time_period.wiki_string(), short_string))
        return contents

    def upload(self, reports, time_periods):
        requests = [self.prepare_report(report, time_periods) for report in reports]
        pool = multiprocessing.Pool(processes=10)
        return pool.map(send_url_request, requests)

    def prepare_report(self, report, time_periods):
        page_name = report.wiki_string()
        contents = self.add_links_for_short_strings(report.generate_report(), time_periods)

        full_save_url = "%s/twiki/bin/save/%s/%s" % (self.url, self.section, page_name)
        full_view_url = "%s/twiki/bin/view/%s/%s" % (self.url, self.section, page_name)
        print "Uploading report to %s" % full_view_url

        request = urllib2.Request(full_save_url)
        request.add_data(urllib.urlencode({'text': contents.encode('latin1')}))

        if self.username and self.password:
            request.add_header('Authorization',
                               'Basic ' + \
                               base64.urlsafe_b64encode("%s:%s" % (self.username,
                                                                   self.password)))
        return request

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-l', '--login', type=str,
                        help="login name for PHPReport and TWiki")
    parser.add_argument('-p', '--project', type=str,
                        help="only consider tasks matching given project search string")
    parser.add_argument('-c', '--customer', type=str,
                        help="only consider tasks matching given customer search string")
    parser.add_argument('-u', '--user', type=str,
                        help="only consider tasks logged by the given user")
    parser.add_argument('-w', '--week', type=str,
                        default = str(datetime.datetime.today().isocalendar()[1]),
                        help="week or week range of tasks to show")
    parser.add_argument('-f', '--formatter', choices=['text', 'twiki'],
                        default="text", help="output format for report")
    parser.add_argument('--twiki', metavar="TWIKI_URL", type=str,
                        help="Use TWiki mode, which uploads both detailed and aggregate reports to the given TWiki URL.")
    parser.add_argument('-n', '--name', type=str,
                        default=None, help="In Twiki mode use it to set the name of the TWiki page for the report.")
    args = parser.parse_args()

    if not args.project and not args.customer and not args.user:
        print "Must give either a customer (-c) search string or a product search string (-p)"
        sys.exit(1)

    PHPReport.login(username=args.login)

    customer = None
    project = None
    user = None
    def filter_instances(instances, search_string):
        terms = search_string.lower().split(',')
        def matches_all(instance):
            for term in terms:
                if not instance.match(term):
                    return False
            return True
        return filter(matches_all, instances)

    # FIXME: We should really support choosing selecting more than one
    # customer or project.
    if args.project != None:
        projects = filter_instances(Project.instances.values(), args.project)
        if not len(projects):
            print "Could not find any projects matching '%s'" % args.project
            sys.exit(1)
        projects.sort()
        project = projects[-1]

    if args.customer != None:
        customers = filter_instances(Customer.instances.values(), args.customer)
        if not len(customers):
            print "Could not find any customers matching '%s'" % args.customer
            sys.exit(1)
        customer = customers[0]

    if args.user != None:
        users = [user for user in User.instances.values() if user.login == args.user]
        if not len(users):
            print "Could not find any customers matching '%s'" % args.customer
            sys.exit(1)
        user = users[0]

    task_filter = TaskFilter(project=project, customer=customer, user=user)
    time_periods = WeekOfWork.create_from_string(args.week, task_filter)

    if args.twiki:
        args.formatter = "twiki"
    if args.formatter == "twiki":
        formatter_class = TwikiFormatter
    else:
        formatter_class = TextFormatter

    reports = []
    if len(time_periods) > 1:
        reports.append(AggregateReport(time_periods, formatter_class(), args.name))
    if len(time_periods) == 1 or args.twiki:
        for period in time_periods:
            reports.append(DetailedReport(period, formatter_class()))

    if args.twiki:
        uploader = TwikiUploader(url=args.twiki,
                                 username=PHPReport.credential.username,
                                 password=PHPReport.credential.password)
        uploader.upload(reports, time_periods)
        sys.exit(0)

    for report in reports:
        print report.generate_report()
